
## Description 
 
 priority queue - первым всегда извлекается самый боольшой( или маленький) элемент
 
 Решение простым массивом (упарядоченным или нет), подходит пллохо, в любом случае возникает операция, которой нужно обойти весь массив = N. 

 binary heap (куча) для всех операций  log N, т.к. размер бинарного дерева log N

## API
- insert(int val) { // insert into priority queue }
- delMax() int { // return and remove largest }
- isEmpty() bool
- max() int
- size() int
## Perfomance
 log N = для всех операций (insert/delete)
 N = для инициализации исходного массива в двоичную кучу
## Summary
Бинарная куча, решение массивом:
- индексы заполняются с 1, для того чтобы выполнялось условие о том, что родительская нода, ноды k, будет находится по адресу k/2. А детские ноды, ноды k, будут с индексами 2k и 2k+1.
- самое болльшое значение кучи heap[1] - это корень бинарного дерева
- значение родителя, никогда не меньше значения потомков 

<img src="/images/BinaryHeap.png" />

## Code Examples

https://play.golang.org/p/eJq-yJUTNFa
